﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿# ascii 48-57:0-9 65-90:A-Z 97-122:a-z# String## String "123" 转 int 123## String 截取 str.substring(start,end)### int temp = Integer.parseInt(str.substring(stard,end);## String 转 char[]字符数组### result.replaceFirst("6","9");### char[] temp = str.toCharArray();## char[]转 String### String.valueOf(int c);## String 长度### int length = str.length();//有()### s.replaceAll(" ","%20");//字符串替换### str.equals("C")### s1.contains(s2)//s1中有没有包含s2### StringBuilder s = new StringBuilder();### s.charAt(size-1);### s.delete(size-1,size);### s.append(pt);### s.toString();### s.toUpperCase()//转大写# int## 乘方计算### int temp = (int)Math.pow(x,y);//return double## 位运算### temp&1 == 1;//判断奇偶### temp>>1;//向右一位## 绝对值最大值最小值### Math.abs(temp);### Math.max(temp);### Math.min(temp);### Math.ceil(temp);//向上取整返回double### (Math.log10(nums[i])+1)# int[]## 初始化### int[] temp = new int[num];### int[] temp = {x,y};### Arrays.sort(temp);//由小到大排序## 二维数组长度### int row = grid.length;### int col = grid[0].length;### Arrays.copyOf(arr,k);//返回前k个数的数组###  Arrays.sort(points, (a, b) -> (a[1] - b[1]));//二维数组按照第二个元素大小排序### Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);//第一个元素相同就按照第二个元素比较，小的在前面，否则第一个元素大的在前面# List## 初始化### List<class> temp = new LinkedList<>();### List<Integer> result = new ArrayList();### List<int[]> result = new ArrayList<>();### result.add(array);### Collections.reverse(result);### Collections.sort(list);//list排序### result.toArray(new int[0][]); ### result.remove(i);//删除### red.addAll(pool[i].subList(0,k - red.size()));//一个列表中添加另一个列表中所有元素## List 转数组### res.toArray(new String[res.size()]);# set## set初始化和常用函数### HashSet<Character> set = new HashSet<>();### set.contains(str);### set.add(str);# Stack## 初始化### Stack<Integer> stack = new Stack();### stack.push(str);### stack.pop();### if(stack.isEmpty());### stack.size()### stack.peek();# Map## 初始化### Map<Integer,Integer> res = new HashMap();### res.containsKey(temp1)### res.put(temp,-1);### res.get(n);### for(int key : map.keySet()) {}### map按照key排序放进queue中PriorityQueue<Map.Entry<Integer,Integer>> queue = new PriorityQueue<>(new Comparator<Map.Entry<Integer,Integer>>() {            @Override            public int compare(Map.Entry<Integer,Integer> o1, Map.Entry<Integer,Integer> o2) {                return o2.getValue() - o1.getValue();            }        });# Queue## 初始化及常用函数### Queue<class> land = new ArrayDeque<>();### land.add();### land.poll()### Queue<TreeNode> pool = new LinkedList<>();### pool.offer(A);### TreeNode temp = pool.poll();### if(pool.size()>0)### pool.peek();## for(Integer x:pool){}//循环遍历##    PriorityQueue<Integer> heap =            new PriorityQueue<Integer>((n1, n2) -> n1 - n2);//小顶堆(小的在顶端)# Deque## 初始化### dq = new LinkedList<>();### dq.size()>0?dq.peek():-1;### dq.peekLast();### dq.offerLast(value);###  dq.pollLast();# Tree## 头root判断### if(root==null);