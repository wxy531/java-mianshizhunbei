﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿# wyx make it# 二分查找法    public int search(int key, int[] array) {    int left =0;    int right = array.length-1;    while(left<=right){    int mid = left + (right-left)/2;    if(array[mid]==key) return mid;    else if(array[mid]<key) left = mid+1;    else() right = mid-1;    }    return -1;    }### 循环条件是left<=right，不是<，012找0会直接退出#### leetcode 69求开方#### leetcode 441 摆硬币(二分写的太麻烦，不如直接计算和)#### leetcode 540 有序双数组的单元素# 贪心思想### 贪心思想保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。#### leetcode 455分发饼干 饼干数组和胃口数组排序，从最小的开始匹配（仅一块）#### leetcode 452用最少的箭射气球，按照右区间排序，射最右边（神仙贪心）#### leetcode 122 买卖股票，遇到减点就卖出买入#### leetcode 605 种植花朵，遇到三个0就种，把0变成1即可#### leetcode 665非递减数列，前两个数挑出来，一个计数器判断#### leetcode 392判断子序列，碰到就++#### leetcode 763划分子区间，总的来说就是比较右边#### leetcode 406根据身高重建队列，先比较高的，后插入矮的到相应的位置上# 双指针### 双指针主要解决数组的遍历#### leetcode 167递增数组的两数之和，头尾逐渐缩小#### leetcode 345反转元音字符串,类似也是头尾逐渐缩小#### leetcode 648回文字符串判断,双指针递归，不相等的时候用个或来尝试左移右移#### leetcode 88合并两个有序数组，从down的末尾和up的m开始#### leetcode 141环形链表 hashset或者快慢指针必相遇#### leetcode 524字符串删除比较字符数组中最长最前字典最小值 # 堆排序### 创建一个大顶堆，来维护第k个大元素查询# 快速选择算法### 快速排序就是从两端找基准数，然后开始大于它的右边小于它的左边交换，相遇和基准数交换，快速排序时间复杂度O(N),比Arrays.sort()(NlogN)快#### leetcode215 第k个大元素查询，上面两种算法解决# 桶排序### 用于频率排序选出最多的几个元素#### 先计算频次然后一个桶队列，每个队列中桶可以装相同频次的索引，长度lenng+1# 搜索# BFS广度优先### 层遍历，用队列存储，每一次记录当前层数节点数，循环一遍再往下，直至0# DFS深度优先### 节点一直往下添加直至没有节点，两个都需要标记经过了的点#### leetcode 695 最大的岛 从头遍历 遇到1变为0,dfs周围的岛点#### leetcode 547 朋友圈 从头开始，used=0圈数加一，将他的朋友dfs设为used=1#### leetcode 200 岛屿数量 相同 从头遍历 遇到1置0 走dfs周围的点置0#### leetcode 257 二叉树的所有叶子节点 节点为空就返回 否则dfs(root.node,String存) #### leetcode 130 O X 被包围的区域，边界是O的dfs，设成P，最后把剩下的O变为X#### leetcode 417 两个海洋流向 两个矩阵 必经两条邻近边 dfs未经过就设为1 大于该点就dfs下一点 最后两个矩阵都是1的点输出#### leetcode 51 N皇后 回溯法 在主对角线 row-col+n-1 相同 在 副对角线上 row+col 相同 判断不能攻击到则放皇后 回溯row+1 之后再移除皇后### 回溯法就是添加一个状态列表，搜索的时候修改状态然后复原状态#### leetcode 17 数字键盘组合 用一个map存储键盘 dfs的时候map里的value长度来循环#### leetcode 79 矩阵里寻找字符串 遍历一遍全矩阵调用dfs dfs里设置一个状态矩阵#### leetcode 93 寻找合理的Ip地址 0~255 加一个指针记录位置 写一个函数判断字符串头不是0且小于256#### leetcode 46 全排列 设置一个状态矩阵即可 注意list<list>添加时需要new list#### leetcode 47 全排列 去重 先排序 nums[i]!=nums[i-1] ||used[i-1]==1才能放到这位置的第一个